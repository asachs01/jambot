"""Tests for LLM-powered chord chart commands."""
import pytest
import discord
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from src.chart_commands import ChartCommands, _create_chart_preview_embed
from src.llm_client import ChartGenerationResponse, Section
from src.database import Database


@pytest.fixture
def mock_db():
    """Mock database instance."""
    db = Mock(spec=Database)
    return db


@pytest.fixture
def mock_bot():
    """Mock Discord bot instance."""
    bot = Mock()
    bot.tree = Mock()
    return bot


@pytest.fixture
def mock_llm_client():
    """Mock LLM client."""
    client = Mock()
    return client


@pytest.fixture
def mock_interaction():
    """Mock Discord interaction."""
    interaction = AsyncMock(spec=discord.Interaction)
    interaction.guild_id = 12345
    interaction.user = Mock()
    interaction.user.id = 67890
    interaction.response = AsyncMock()
    interaction.followup = AsyncMock()
    return interaction


@pytest.fixture
def mock_premium_client():
    """Mock premium API client."""
    client = Mock()
    client.generate_chart = AsyncMock()
    client.render_pdf = AsyncMock(return_value=b'%PDF-mock')
    return client


@pytest.fixture
def sample_chart_data():
    """Sample chart data for testing."""
    return {
        'id': 1,
        'title': 'Mountain Dew',
        'artist': 'Traditional',
        'keys': [{
            'key': 'G',
            'sections': [
                {
                    'label': 'Verse',
                    'rows': 4,
                    'chords': ['G', 'G', 'C', 'G', 'D', 'D', 'G', 'G']
                },
                {
                    'label': 'Chorus',
                    'rows': 4,
                    'chords': ['C', 'C', 'G', 'G', 'D', 'D', 'G', 'G']
                }
            ]
        }],
        'status': 'approved',
        'source': 'user_created',
    }


class TestChartPreviewEmbed:
    """Test suite for _create_chart_preview_embed function."""

    def test_create_embed_for_approved_chart(self, sample_chart_data):
        """Test embed creation for approved chart."""
        embed = _create_chart_preview_embed(sample_chart_data)

        assert isinstance(embed, discord.Embed)
        assert "Mountain Dew" in embed.title
        assert "Traditional" in embed.title
        assert embed.color == discord.Color.blue()
        assert len(embed.fields) == 2  # First 2 sections
        assert embed.fields[0].name == 'Verse'
        assert "G  G  C  G" in embed.fields[0].value
        assert embed.footer.text == "Status: Approved"

    def test_create_embed_for_draft_chart(self, sample_chart_data):
        """Test embed creation for draft chart."""
        sample_chart_data['status'] = 'draft'
        sample_chart_data['source'] = 'ai_generated'

        embed = _create_chart_preview_embed(sample_chart_data)

        assert embed.color == discord.Color.yellow()
        assert "Draft | Generated by AI" in embed.footer.text

    def test_create_embed_without_artist(self, sample_chart_data):
        """Test embed creation for chart without artist."""
        del sample_chart_data['artist']

        embed = _create_chart_preview_embed(sample_chart_data)

        assert embed.title == "Mountain Dew"
        assert " by " not in embed.title

    def test_create_embed_chord_grid_format(self, sample_chart_data):
        """Test chord grid formatting (4 chords per line)."""
        embed = _create_chart_preview_embed(sample_chart_data)

        # Verify monospace code block format
        verse_value = embed.fields[0].value
        assert "```" in verse_value
        assert "G  G  C  G" in verse_value
        assert "D  D  G  G" in verse_value


class TestChartCommandsGenerate:
    """Test suite for /jambot-chart generate command."""

    @pytest.mark.asyncio
    async def test_generate_missing_song_title(self, mock_db, mock_bot, mock_interaction):
        """Test generate command with missing song title."""
        commands = ChartCommands(mock_bot, mock_db)

        await commands._handle_generate(mock_interaction, None)

        mock_interaction.response.send_message.assert_called_once()
        call_args = mock_interaction.response.send_message.call_args
        assert "provide a song title" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_with_existing_approved_chart(self, mock_db, mock_bot, mock_interaction, sample_chart_data, mock_premium_client):
        """Test generate command returns existing approved chart."""
        commands = ChartCommands(mock_bot, mock_db)
        commands.premium_client = mock_premium_client
        mock_db.fuzzy_search_chord_chart.return_value = sample_chart_data
        mock_db.get_guild_premium_token = Mock(return_value='test-token')

        with patch('src.chart_commands.render_chart_pdf_via_api', new_callable=AsyncMock) as mock_render:
            mock_render.return_value = b'%PDF-mock'

            await commands._handle_generate(mock_interaction, "Mountain Dew")

            mock_interaction.response.defer.assert_called_once()
            mock_db.fuzzy_search_chord_chart.assert_called_once_with(12345, "Mountain Dew")
            mock_interaction.followup.send.assert_called_once()

            # Should find existing chart
            call_args = mock_interaction.followup.send.call_args
            assert "found existing chart" in call_args[0][0].lower() or "mountain dew" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_with_existing_draft_chart(self, mock_db, mock_bot, mock_interaction, sample_chart_data):
        """Test generate command with existing draft chart."""
        commands = ChartCommands(mock_bot, mock_db)
        sample_chart_data['status'] = 'draft'
        mock_db.fuzzy_search_chord_chart.return_value = sample_chart_data

        await commands._handle_generate(mock_interaction, "Mountain Dew")

        mock_interaction.response.defer.assert_called_once()
        call_args = mock_interaction.followup.send.call_args
        # Draft charts show pending approval message
        assert "pending approval" in call_args[0][0].lower() or "draft" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_creates_new_chart_via_premium_api(self, mock_db, mock_bot, mock_interaction):
        """Test generate command creates new chart via premium API."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = None
        mock_db.get_premium_config = Mock(return_value={'premium_api_token': 'test-token'})

        # Create a mock response object
        mock_result = Mock()
        mock_result.success = True
        mock_result.chart = {
            'title': 'Wildwood Flower',
            'key': 'C',
            'sections': [{'label': 'Verse', 'rows': 4, 'chords': ['C', 'F', 'G', 'C']}],
            'lyrics': []
        }
        mock_result.pdf = b'%PDF-mock'
        mock_result.data_source = 'ai_generated'
        mock_result.credits_remaining = 9

        # Patch the PremiumClient class
        with patch('src.chart_commands.PremiumClient') as MockPremiumClient:
            mock_client_instance = AsyncMock()
            mock_client_instance.generate_chart = AsyncMock(return_value=mock_result)
            MockPremiumClient.return_value.__aenter__ = AsyncMock(return_value=mock_client_instance)
            MockPremiumClient.return_value.__aexit__ = AsyncMock(return_value=None)

            await commands._handle_generate(mock_interaction, "Wildwood Flower by Carter Family")

            mock_interaction.response.defer.assert_called_once()
            # Verify premium API called
            mock_client_instance.generate_chart.assert_called_once()

    @pytest.mark.asyncio
    async def test_generate_handles_no_premium_token(self, mock_db, mock_bot, mock_interaction):
        """Test generate command handles missing premium token."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = None
        mock_db.get_guild_premium_token = Mock(return_value=None)

        await commands._handle_generate(mock_interaction, "Test Song")

        mock_interaction.response.defer.assert_called_once()
        call_args = mock_interaction.followup.send.call_args
        assert "premium" in call_args[0][0].lower() or "token" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_handles_api_exception(self, mock_db, mock_bot, mock_interaction, mock_premium_client):
        """Test generate command handles API exceptions."""
        commands = ChartCommands(mock_bot, mock_db)
        commands.premium_client = mock_premium_client
        mock_db.fuzzy_search_chord_chart.return_value = None
        mock_db.get_guild_premium_token = Mock(return_value='test-token')
        mock_premium_client.generate_chart = AsyncMock(side_effect=Exception("API error"))

        await commands._handle_generate(mock_interaction, "Test Song")

        mock_interaction.response.defer.assert_called_once()
        call_args = mock_interaction.followup.send.call_args
        # Should show error message
        assert call_args is not None


class TestDatabaseFuzzySearch:
    """Test suite for database fuzzy search functionality."""

    def test_fuzzy_search_chord_chart_exact_match(self, mock_db):
        """Test fuzzy search finds exact title match."""
        # This would be an integration test with real database
        # Skipping mock implementation as it's covered by database tests
        pass

    def test_fuzzy_search_chord_chart_close_match(self, mock_db):
        """Test fuzzy search finds close match with typos."""
        # Integration test - covered by database tests
        pass

    def test_fuzzy_search_chord_chart_alternate_titles(self, mock_db):
        """Test fuzzy search matches alternate titles."""
        # Integration test - covered by database tests
        pass
