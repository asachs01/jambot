"""Tests for LLM-powered chord chart commands."""
import pytest
import discord
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from src.chart_commands import ChartCommands, _create_chart_preview_embed
from src.llm_client import ChartGenerationResponse, Section
from src.database import Database


@pytest.fixture
def mock_db():
    """Mock database instance."""
    db = Mock(spec=Database)
    return db


@pytest.fixture
def mock_bot():
    """Mock Discord bot instance."""
    bot = Mock()
    bot.tree = Mock()
    return bot


@pytest.fixture
def mock_llm_client():
    """Mock LLM client."""
    client = Mock()
    return client


@pytest.fixture
def mock_interaction():
    """Mock Discord interaction."""
    interaction = AsyncMock(spec=discord.Interaction)
    interaction.guild_id = 12345
    interaction.user = Mock()
    interaction.user.id = 67890
    interaction.response = AsyncMock()
    interaction.followup = AsyncMock()
    return interaction


@pytest.fixture
def sample_chart_data():
    """Sample chart data for testing."""
    return {
        'id': 1,
        'title': 'Mountain Dew',
        'artist': 'Traditional',
        'keys': [{
            'key': 'G',
            'sections': [
                {
                    'label': 'Verse',
                    'chords': ['G', 'G', 'C', 'G', 'D', 'D', 'G', 'G']
                },
                {
                    'label': 'Chorus',
                    'chords': ['C', 'C', 'G', 'G', 'D', 'D', 'G', 'G']
                }
            ]
        }],
        'status': 'approved',
        'source': 'user_created',
    }


class TestChartPreviewEmbed:
    """Test suite for _create_chart_preview_embed function."""

    def test_create_embed_for_approved_chart(self, sample_chart_data):
        """Test embed creation for approved chart."""
        embed = _create_chart_preview_embed(sample_chart_data)

        assert isinstance(embed, discord.Embed)
        assert "Mountain Dew" in embed.title
        assert "Traditional" in embed.title
        assert embed.color == discord.Color.blue()
        assert len(embed.fields) == 2  # First 2 sections
        assert embed.fields[0].name == 'Verse'
        assert "G  G  C  G" in embed.fields[0].value
        assert embed.footer.text == "Status: Approved"

    def test_create_embed_for_draft_chart(self, sample_chart_data):
        """Test embed creation for draft chart."""
        sample_chart_data['status'] = 'draft'
        sample_chart_data['source'] = 'ai_generated'

        embed = _create_chart_preview_embed(sample_chart_data)

        assert embed.color == discord.Color.yellow()
        assert "Draft | Generated by AI" in embed.footer.text

    def test_create_embed_without_artist(self, sample_chart_data):
        """Test embed creation for chart without artist."""
        del sample_chart_data['artist']

        embed = _create_chart_preview_embed(sample_chart_data)

        assert embed.title == "Mountain Dew"
        assert " by " not in embed.title

    def test_create_embed_chord_grid_format(self, sample_chart_data):
        """Test chord grid formatting (4 chords per line)."""
        embed = _create_chart_preview_embed(sample_chart_data)

        # Verify monospace code block format
        verse_value = embed.fields[0].value
        assert "```" in verse_value
        assert "G  G  C  G" in verse_value
        assert "D  D  G  G" in verse_value


class TestChartCommandsGenerate:
    """Test suite for /jambot-chart generate command."""

    @pytest.mark.asyncio
    async def test_generate_missing_song_title(self, mock_db, mock_bot, mock_interaction):
        """Test generate command with missing song title."""
        commands = ChartCommands(mock_bot, mock_db)

        await commands._handle_generate(mock_interaction, None)

        mock_interaction.response.send_message.assert_called_once()
        call_args = mock_interaction.response.send_message.call_args
        assert "provide a song title" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_with_existing_approved_chart(self, mock_db, mock_bot, mock_interaction, sample_chart_data):
        """Test generate command returns existing approved chart."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = sample_chart_data

        await commands._handle_generate(mock_interaction, "Mountain Dew")

        mock_interaction.response.defer.assert_called_once()
        mock_db.fuzzy_search_chord_chart.assert_called_once_with(12345, "Mountain Dew")
        mock_interaction.followup.send.assert_called_once()

        call_args = mock_interaction.followup.send.call_args
        assert "existing approved chart" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_with_existing_draft_chart(self, mock_db, mock_bot, mock_interaction, sample_chart_data):
        """Test generate command with existing draft chart."""
        commands = ChartCommands(mock_bot, mock_db)
        sample_chart_data['status'] = 'draft'
        mock_db.fuzzy_search_chord_chart.return_value = sample_chart_data

        await commands._handle_generate(mock_interaction, "Mountain Dew")

        mock_interaction.response.defer.assert_called_once()
        call_args = mock_interaction.followup.send.call_args
        assert "not approved yet" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_parses_artist_from_by_pattern(self, mock_db, mock_bot, mock_interaction):
        """Test generate command parses artist from 'Song by Artist' format."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = None

        # Mock LLM client
        mock_response = ChartGenerationResponse(
            title="Foggy Mountain Breakdown",
            artist="Earl Scruggs",
            key="G",
            sections=[Section(label="Verse", chords=["G", "C", "D", "G"])]
        )
        commands.llm_client.generate_chord_chart = Mock(return_value=mock_response)
        mock_db.create_chord_chart.return_value = 1

        await commands._handle_generate(mock_interaction, "Foggy Mountain Breakdown by Earl Scruggs")

        mock_interaction.response.defer.assert_called_once()
        commands.llm_client.generate_chord_chart.assert_called_once_with(
            "Foggy Mountain Breakdown", "Earl Scruggs"
        )

    @pytest.mark.asyncio
    async def test_generate_creates_new_chart_via_llm(self, mock_db, mock_bot, mock_interaction):
        """Test generate command creates new chart via LLM."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = None

        # Mock LLM response
        mock_response = ChartGenerationResponse(
            title="Wildwood Flower",
            artist="Carter Family",
            key="C",
            sections=[
                Section(label="Verse", chords=["C", "F", "G", "C", "C", "F", "G", "C"])
            ]
        )
        commands.llm_client.generate_chord_chart = Mock(return_value=mock_response)
        mock_db.create_chord_chart.return_value = 1
        mock_db.create_generation_history.return_value = 1

        await commands._handle_generate(mock_interaction, "Wildwood Flower by Carter Family")

        # Verify LLM called
        commands.llm_client.generate_chord_chart.assert_called_once()

        # Verify chart stored as draft
        mock_db.create_chord_chart.assert_called_once()
        call_args = mock_db.create_chord_chart.call_args[1]
        assert call_args['status'] == 'draft'
        assert call_args['source'] == 'ai_generated'
        assert call_args['title'] == 'Wildwood Flower'

        # Verify generation history saved
        mock_db.create_generation_history.assert_called_once()

        # Verify embed preview sent
        mock_interaction.followup.send.assert_called_once()

    @pytest.mark.asyncio
    async def test_generate_handles_llm_value_error(self, mock_db, mock_bot, mock_interaction):
        """Test generate command handles ValueError from LLM client."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = None
        commands.llm_client.generate_chord_chart = Mock(
            side_effect=ValueError("No LLM API key configured")
        )

        await commands._handle_generate(mock_interaction, "Test Song")

        mock_interaction.response.defer.assert_called_once()
        call_args = mock_interaction.followup.send.call_args
        assert "not available" in call_args[0][0].lower()

    @pytest.mark.asyncio
    async def test_generate_handles_generic_exception(self, mock_db, mock_bot, mock_interaction):
        """Test generate command handles generic exceptions."""
        commands = ChartCommands(mock_bot, mock_db)
        mock_db.fuzzy_search_chord_chart.return_value = None
        commands.llm_client.generate_chord_chart = Mock(
            side_effect=Exception("API error")
        )

        await commands._handle_generate(mock_interaction, "Test Song")

        mock_interaction.response.defer.assert_called_once()
        call_args = mock_interaction.followup.send.call_args
        assert "failed" in call_args[0][0].lower()


class TestDatabaseFuzzySearch:
    """Test suite for database fuzzy search functionality."""

    def test_fuzzy_search_chord_chart_exact_match(self, mock_db):
        """Test fuzzy search finds exact title match."""
        # This would be an integration test with real database
        # Skipping mock implementation as it's covered by database tests
        pass

    def test_fuzzy_search_chord_chart_close_match(self, mock_db):
        """Test fuzzy search finds close match with typos."""
        # Integration test - covered by database tests
        pass

    def test_fuzzy_search_chord_chart_alternate_titles(self, mock_db):
        """Test fuzzy search matches alternate titles."""
        # Integration test - covered by database tests
        pass
