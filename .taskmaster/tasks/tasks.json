{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Setup and Environment Configuration",
        "description": "Initialize the Python project, set up Docker, configure environment variables, and prepare for Discord and Spotify integration.",
        "details": "Use Python 3.11+. Create a Dockerfile that installs dependencies (discord.py v2.x, spotipy v2.23+, sqlite3, python-dotenv). Prepare a .env.example file with all required variables. Ensure persistent volume for SQLite. Configure DigitalOcean Container App deployment with resource limits (512MB RAM, 0.5 vCPU, 1GB volume). Use python-dotenv to load environment variables securely. Set file permissions for the SQLite database to restrict access to the bot process only.",
        "testStrategy": "Verify container builds and runs locally. Check that environment variables are loaded and accessible. Confirm database file permissions are correct. Deploy to DigitalOcean and ensure bot starts and persists database after restart.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "2",
        "title": "Discord Bot Initialization and Message Monitoring",
        "description": "Implement Discord bot startup, connect to server, and monitor messages from the configured jam leader for setlist detection.",
        "details": "Use discord.py v2.x with required intents (Message Content, Server Members). Authenticate using DISCORD_BOT_TOKEN from .env. Monitor messages in specified channels from DISCORD_JAM_LEADER_ID. Implement async/await for all Discord operations. Log all bot startup and message events using Python's logging module with rotating file handler.",
        "testStrategy": "Post test messages as jam leader and verify bot detects them. Confirm bot logs all events and errors. Simulate Discord API errors and check error handling and logging.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "3",
        "title": "Setlist Message Parsing and Extraction",
        "description": "Parse detected setlist messages, extract jam date, time, and song list, allowing for minor intro text variations.",
        "details": "Use regular expressions to match setlist patterns, extracting date, time, and numbered song titles (strip key info). Implement robust parsing to handle minor variations in intro text. Validate extracted data and log warnings for unrecognized formats. Store parsed setlist in memory for further processing.",
        "testStrategy": "Test with multiple setlist message formats. Validate extraction accuracy against acceptance criteria. Log and skip unrecognized formats.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "4",
        "title": "SQLite Database Schema Design and Implementation",
        "description": "Design and implement the SQLite database schema for songs, setlists, and setlist-song relationships.",
        "details": "Create tables: songs, setlists, setlist_songs as specified. Use sqlite3 with connection pooling for reliability. Ensure atomic transactions for all write operations. Implement schema migrations using Alembic or a simple versioning script. Set up indices on song_title and setlist date for fast lookups. Use parameterized queries to prevent SQL injection.",
        "testStrategy": "Run schema creation and migration scripts. Validate table structure and constraints. Test atomicity by simulating concurrent writes. Verify indices improve query performance.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Song Matching: Database Lookup and Spotify Search",
        "description": "For each song, check for previously approved versions in the database, otherwise search Spotify for matches.",
        "details": "For each song, query the songs table for existing version. If not found, use spotipy v2.23+ to search Spotify with exact title. If no match, try common bluegrass variations (maintain a mapping or use a configurable list). Limit fuzzy matching to avoid irrelevant results. Return up to 3 matches per new song, capturing track name, artist, album, Spotify track ID, and URL. Handle Spotify API rate limits with exponential backoff and retries.",
        "testStrategy": "Test with songs present and absent in the database. Validate Spotify search results for accuracy and relevance. Simulate rate limits and verify retry logic.",
        "priority": "high",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Admin Validation Workflow via Discord DM",
        "description": "Send a DM to the admin with song match details, support emoji-based approval, manual overrides, and summary confirmation.",
        "details": "Use discord.py to send formatted DMs to DISCORD_ADMIN_ID. For each song, display: pre-approved version (✅), single match (✅), multiple matches (1️⃣ 2️⃣ 3️⃣), or no match (❌, prompt for link). Listen for emoji reactions and message replies. Allow admin to override with Spotify link. After all songs, present summary and request final approval. Implement async/await for all Discord operations. Log all admin actions for audit.",
        "testStrategy": "Simulate setlist detection and verify DM formatting. Test all approval scenarios (emoji, manual link, skip). Confirm summary and final approval flow. Validate logging of admin actions.",
        "priority": "high",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Manual Song Management Command Implementation",
        "description": "Implement the '@jambot use this version of [song name] for [setlist date] [spotify link]' command for manual overrides.",
        "details": "Parse command using discord.py command framework. Validate Spotify link format using regex. Update song version in setlist (if before playlist creation) and in songs table for future use. Confirm update to admin via DM. Log all manual overrides for audit. Ensure command is only accessible to admin.",
        "testStrategy": "Test command with valid and invalid Spotify links. Verify updates in database and setlist. Confirm admin receives confirmation. Check access control.",
        "priority": "medium",
        "dependencies": [
          "4",
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Spotify Playlist Creation and Posting",
        "description": "Create Spotify playlist under configured account, add approved tracks in order, and post link to Discord channel.",
        "details": "Use spotipy with OAuth refresh token for authentication. Create playlist named 'Bluegrass Jam [MM/DD/YYYY]'. Add tracks in setlist order. Handle API errors gracefully, retry if needed, and notify admin if failure persists. Post playlist link to original Discord channel using discord.py. Store playlist info in setlists table. Ensure playlist-modify-public/private scopes are set.",
        "testStrategy": "Approve setlist and trigger playlist creation. Validate playlist name, track order, and link posting. Simulate Spotify API errors and verify error handling and admin notification.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Song Version Memory and Setlist History Management",
        "description": "Update song usage dates, maintain setlist-song relationships, and ensure version consistency across sessions.",
        "details": "On playlist creation, update last_used date for each song in songs table. Insert setlist and setlist_songs records to maintain history. Ensure first_used is set for new songs. Implement queries to retrieve version consistency stats. Use indices for efficient lookups. Log all updates for audit.",
        "testStrategy": "Create multiple setlists with repeat songs. Verify last_used and first_used dates update correctly. Check setlist-song relationships in database. Validate version consistency rate.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Comprehensive Error Handling, Logging, and Documentation",
        "description": "Implement robust error handling, logging, and provide complete setup and admin documentation.",
        "details": "Use Python logging with INFO/ERROR levels, rotating file handler, and stdout. Log timestamp, level, module, message. Handle all error scenarios (Discord/Spotify API, database, playlist creation) with retries and admin notifications. Document setup (README), .env.example, database schema, deployment guide, admin workflow, and troubleshooting. Ensure code is well-commented and uses async/await throughout.",
        "testStrategy": "Simulate all error scenarios and verify logging and notifications. Review documentation for completeness and clarity. Check code comments and async usage.",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "Implement Modal-Based Configuration System for Jam Leaders and Approvers",
        "description": "Replace environment variable configuration for jam leaders and song approvers with a Discord modal-based UI, accessible via a /jambot setup slash command, storing configuration in the database and enforcing admin-only access.",
        "details": "1. Use discord.py v2.x's support for modals and slash commands to implement a /jambot setup command. When invoked, check that the user has administrator permissions in the server (using `interaction.user.guild_permissions.administrator`).\n\n2. On valid invocation, present a modal to the user. The modal should include Discord user select components for configuring multiple jam leaders and song approvers. Use the Discord API's User Select component in modals, allowing up to 25 users per select as per Discord's documented limits[2].\n\n3. On modal submission, extract the selected user IDs for both jam leaders and approvers from the interaction data. Validate that at least one jam leader and one approver are selected.\n\n4. Store the configuration in the database (e.g., a new 'configuration' table or as part of a 'settings' table), associating the selected user IDs with the guild/server ID. Ensure atomic writes and handle concurrent updates safely.\n\n5. Remove any use of environment variables for jam leader and approver configuration. Retain environment variables only for bot token and Spotify credentials.\n\n6. Provide clear feedback to the admin on success or failure of the configuration update, and log all configuration changes for audit purposes.\n\n7. Follow Discord's best practices for modal interaction handling: show the modal as the first response to the slash command interaction, and handle modal submissions in a dedicated event handler[3][5].\n\n8. Ensure code is well-structured, with clear separation between command registration, permission checks, modal construction, submission handling, and database operations.",
        "testStrategy": "1. Register the /jambot setup command and verify it is only accessible to server admins.\n\n2. Invoke the command as an admin and confirm the modal appears with user select components for both jam leaders and approvers, supporting multiple selections.\n\n3. Submit the modal with various valid and invalid combinations (e.g., no selection, duplicate users) and verify correct validation and error handling.\n\n4. Check that the selected user IDs are correctly stored in the database and associated with the correct guild.\n\n5. Attempt to invoke the command as a non-admin and confirm access is denied.\n\n6. Confirm that environment variables for jam leader and approver are no longer used, and that bot token and Spotify credentials remain environment-based.\n\n7. Review logs to ensure all configuration changes are recorded with timestamps and user IDs.\n\n8. Simulate concurrent configuration updates and verify database consistency.",
        "status": "done",
        "dependencies": [
          "2",
          "4"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Register /jambot setup Slash Command with Admin-Only Access",
            "description": "Implement the /jambot setup slash command using discord.py v2.x, ensuring only server administrators can invoke it.",
            "dependencies": [],
            "details": "Use discord.py's app_commands to register the slash command. In the command handler, check interaction.user.guild_permissions.administrator before proceeding. If the user lacks permissions, respond with an error message and do not show the modal.",
            "status": "done",
            "testStrategy": "Attempt to invoke the command as both admin and non-admin users. Confirm only admins can access the modal.",
            "updatedAt": "2025-11-17T14:31:00.098Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design and Present Modal with User Select Components for Jam Leaders and Approvers",
            "description": "Create a modal dialog that allows admins to select multiple Discord users as jam leaders and song approvers, using Discord's User Select component.",
            "dependencies": [
              1
            ],
            "details": "On valid command invocation, present a modal using discord.ui.Modal. Add two user select components, each supporting up to 25 users, for jam leaders and approvers. Ensure the modal is shown as the first response to the interaction.",
            "status": "done",
            "testStrategy": "Invoke the command as an admin and verify the modal appears with both user select components, supporting multiple selections.",
            "parentId": "undefined",
            "updatedAt": "2025-11-17T14:31:01.604Z"
          },
          {
            "id": 3,
            "title": "Handle Modal Submission and Validate Selected Users",
            "description": "Process modal submissions, extract selected user IDs for jam leaders and approvers, and validate that at least one user is selected for each role.",
            "dependencies": [
              2
            ],
            "details": "Implement a callback for modal submission. Extract user IDs from the interaction data. Check that at least one jam leader and one approver are selected. If validation fails, send an error message to the admin.",
            "status": "done",
            "testStrategy": "Submit the modal with various valid and invalid selections. Confirm validation logic and error handling work as expected.",
            "parentId": "undefined",
            "updatedAt": "2025-11-17T14:31:03.255Z"
          },
          {
            "id": 4,
            "title": "Store Configuration in Database and Remove Environment Variable Usage",
            "description": "Persist the selected jam leaders and approvers in the database, associating them with the guild ID, and eliminate environment variable usage for these roles.",
            "dependencies": [
              3
            ],
            "details": "Create or update a configuration/settings table in the database to store user IDs for jam leaders and approvers per guild. Ensure atomic writes and safe concurrent updates. Refactor code to remove environment variable checks for these roles, retaining them only for bot token and Spotify credentials.",
            "status": "done",
            "testStrategy": "Verify database updates after modal submission. Confirm environment variables are no longer used for jam leader/approver configuration.",
            "parentId": "undefined",
            "updatedAt": "2025-11-17T14:32:37.492Z"
          },
          {
            "id": 5,
            "title": "Provide Feedback, Log Configuration Changes, and Ensure Code Structure",
            "description": "Send clear feedback to admins on configuration success or failure, log all changes for audit, and maintain separation of concerns in code structure.",
            "dependencies": [
              4
            ],
            "details": "After database update, send a success or error message to the admin. Log all configuration changes with timestamp, user, and details. Ensure code is organized with separate modules/functions for command registration, permission checks, modal construction, submission handling, and database operations.",
            "status": "done",
            "testStrategy": "Check admin receives appropriate feedback. Review logs for completeness. Inspect code for clear separation of concerns.",
            "parentId": "undefined",
            "updatedAt": "2025-11-17T14:32:38.964Z"
          }
        ],
        "updatedAt": "2025-11-17T14:32:38.964Z"
      },
      {
        "id": "12",
        "title": "Fix Workflow Cleanup Bug: Preserve Active Workflows When Missing Songs Detected",
        "description": "Fix the bug where re-adding ✅ reaction after fixing missing song selections doesn't trigger playlist creation because the workflow is prematurely cleaned up in the finally block.",
        "details": "ROOT CAUSE: The create_playlist_from_workflow() function in src/bot.py (lines 764-772) has a try/finally block where cleanup_workflow() is unconditionally called in the finally clause. When missing songs are detected (lines 641-664), the function returns early but the finally block still executes, removing the workflow from self.active_workflows. When users later fix missing songs and re-add ✅, on_raw_reaction_add() can't find the workflow and silently ignores the reaction.\n\nIMPLEMENTATION STEPS:\n1. Remove cleanup_workflow() from the finally block (lines 764-772) in create_playlist_from_workflow()\n2. Add explicit cleanup_workflow() call at the end of successful playlist creation path (after playlist is created and posted)\n3. Ensure cleanup_workflow() is called in the cancellation handler (❌ reaction path)\n4. Do NOT call cleanup_workflow() when returning early due to missing songs (lines 641-664) - the workflow must remain active\n5. Add logging statements to track workflow lifecycle:\n   - Log when workflow is created/added to active_workflows\n   - Log when missing songs are detected (workflow should remain active)\n   - Log when workflow is successfully completed (before cleanup)\n   - Log when workflow is cancelled (before cleanup)\n   - Log when cleanup_workflow() is called with workflow_id\n\nSPECIFIC CODE CHANGES:\n- src/bot.py lines 764-772: Remove the finally block entirely or remove cleanup_workflow() from it\n- src/bot.py lines 641-664: Add logging statement confirming workflow remains active when missing songs detected\n- src/bot.py: Add cleanup_workflow() call after successful playlist creation (after posting to Discord)\n- src/bot.py lines 565-624: Verify on_raw_reaction_add() properly handles re-triggering for existing workflows\n- src/bot.py: Add cleanup_workflow() to cancellation (❌) reaction handler if not already present\n- Add debug logging throughout workflow lifecycle for troubleshooting\n\nEDGE CASES TO HANDLE:\n- Multiple missing song detection cycles (user adds ✅ multiple times before fixing all songs)\n- User cancels (❌) after missing songs detected - should still clean up\n- Concurrent reactions on same workflow\n- Workflow timeout scenarios (if implemented)",
        "testStrategy": "1. MISSING SONGS WORKFLOW TEST:\n   - Trigger setlist detection with intentionally incomplete song selections\n   - Add ✅ reaction and verify error message is sent indicating missing songs\n   - Check logs to confirm workflow remains in active_workflows (not cleaned up)\n   - Select the missing songs using number reactions\n   - Remove and re-add ✅ reaction\n   - Verify playlist creation is successfully triggered\n   - Confirm workflow is cleaned up after successful creation\n\n2. SUCCESSFUL CREATION TEST:\n   - Complete full workflow with all songs selected\n   - Add ✅ reaction\n   - Verify playlist is created and posted\n   - Check logs to confirm cleanup_workflow() is called\n   - Verify workflow is removed from active_workflows\n\n3. CANCELLATION TEST:\n   - Start workflow with missing songs\n   - Add ✅ to trigger missing songs error\n   - Add ❌ reaction to cancel\n   - Verify workflow is cleaned up\n   - Check logs to confirm cleanup_workflow() was called\n\n4. MULTIPLE MISSING SONGS CYCLES:\n   - Add ✅ with some songs missing\n   - Select some (but not all) missing songs\n   - Re-add ✅ and verify still shows missing songs error\n   - Workflow should still be active\n   - Complete all selections and re-add ✅\n   - Verify successful playlist creation\n\n5. LOGGING VERIFICATION:\n   - Review logs for all test scenarios\n   - Confirm workflow lifecycle is properly tracked (creation, missing songs detection, completion, cleanup)\n   - Verify no silent failures or orphaned workflows\n\n6. REGRESSION TEST:\n   - Run through normal happy path workflow to ensure no functionality was broken\n   - Verify all existing approval scenarios still work correctly",
        "status": "done",
        "dependencies": [
          "6",
          "8"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-17T00:51:10.964Z"
      },
      {
        "id": "13",
        "title": "Fix Bug: Persist Manual DM Song Submissions to Database Immediately",
        "description": "Fix the bug where songs submitted via manual DM reply to song suggestion embeds are only stored in memory but not persisted to the database until playlist creation, causing data loss if the approval workflow doesn't complete.",
        "details": "ROOT CAUSE: In src/bot.py, the handle_dm_message() function (line 155) allows users to reply to song suggestion embeds with Spotify URLs. When they do, it updates workflow['selections'][song_number] in memory (line 232) and sends a confirmation message (lines 240-245), but never calls db.add_or_update_song() to persist the song to the database. Songs are only stored when create_playlist_from_workflow() runs (triggered by ✅ reaction on summary message).\n\nIMPLEMENTATION STEPS:\n1. Locate the handle_dm_message() function in src/bot.py around line 155\n2. After the line that updates workflow['selections'][song_number] (line 232), add a call to persist the song immediately\n3. Extract the guild_id from the workflow dictionary (workflow['guild_id'])\n4. Call self.db.add_or_update_song() with the following parameters:\n   - guild_id: from workflow dict\n   - song_title: the song name from the workflow\n   - spotify_track_id: extracted from the Spotify URL\n   - spotify_url: the URL provided by the user\n   - artist: extract from Spotify track info\n   - album: extract from Spotify track info\n5. Add logging statement: logger.info(f\"Stored manual song submission for '{song_title}' via DM reply to database\")\n6. Wrap the database call in try/except to handle any database errors gracefully and notify the user if storage fails\n7. Ensure the confirmation message (lines 240-245) still sends to the user after successful storage\n8. The song will still be linked to the setlist later when approval completes (existing behavior in create_playlist_from_workflow)\n\nEXAMPLE CODE LOCATION:\n- Reference src/bot.py lines 713-721 for how songs ARE properly stored in create_playlist_from_workflow()\n- Use the same db.add_or_update_song() method pattern from src/database.py line 159\n\nERROR HANDLING:\n- If database storage fails, log the error and notify the user that their submission was received but may need to be resubmitted\n- Ensure workflow selections are still updated even if database storage fails (graceful degradation)",
        "testStrategy": "1. MANUAL SONG SUBMISSION TEST:\n   - Trigger setlist detection workflow with songs that need manual selection\n   - Reply to a song suggestion embed via DM with a valid Spotify URL\n   - Verify confirmation message is sent to the user\n   - Query the songs table directly and confirm the song was stored with correct spotify_track_id, spotify_url, artist, and album\n   - Check logs for \"Stored manual song submission\" message\n\n2. WORKFLOW COMPLETION TEST:\n   - After manual song submission, complete the approval workflow by adding ✅ reaction\n   - Verify playlist is created successfully\n   - Confirm the manually submitted song appears in the playlist\n   - Check that setlist_songs table contains the link between the song and setlist\n\n3. INCOMPLETE WORKFLOW TEST:\n   - Submit a song manually via DM reply\n   - Do NOT complete the approval workflow (don't add ✅ reaction)\n   - Query the songs table and verify the song is still stored\n   - Restart the bot and verify the song remains in the database\n\n4. DATABASE ERROR HANDLING TEST:\n   - Simulate a database error (temporarily make database read-only or disconnect)\n   - Submit a song via DM reply\n   - Verify user receives appropriate error notification\n   - Confirm workflow selections are still updated in memory\n   - Restore database and verify subsequent submissions work correctly\n\n5. LOGGING VERIFICATION:\n   - Review logs after manual song submission\n   - Confirm log entry includes song title, guild_id, and success/failure status\n   - Verify log level is appropriate (INFO for success, ERROR for failures)",
        "status": "done",
        "dependencies": [
          "4",
          "5"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-17T01:03:17.918Z"
      },
      {
        "id": "14",
        "title": "Persist Active Approval Workflows to Database",
        "description": "Create database persistence layer for approval workflows to prevent data loss during bot restarts, disconnections, or crashes by storing workflow state in a database table instead of memory-only storage.",
        "details": "PROBLEM ANALYSIS:\nCurrently, active_workflows is stored as an in-memory Dict in bot.py. When the bot restarts, disconnects, or crashes, all in-progress approval workflows are lost, forcing users to start over even if they've already made song selections.\n\nDATABASE SCHEMA:\nCreate a new table in database.py:\n\n```sql\nCREATE TABLE active_workflows (\n    id SERIAL PRIMARY KEY,\n    guild_id BIGINT NOT NULL,\n    summary_message_id BIGINT UNIQUE NOT NULL,\n    original_channel_id BIGINT,\n    original_message_id BIGINT,\n    song_matches JSONB NOT NULL,  -- array of song match objects\n    selections JSONB DEFAULT '{}',  -- song_number -> selected track mapping\n    message_ids JSONB DEFAULT '[]',  -- array of DM message IDs\n    approver_ids JSONB DEFAULT '[]',  -- array of approver user IDs\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_active_workflows_summary_message ON active_workflows(summary_message_id);\nCREATE INDEX idx_active_workflows_guild ON active_workflows(guild_id);\n```\n\nIMPLEMENTATION STEPS:\n\n1. **Update database.py schema initialization:**\n   - Add active_workflows table creation to the init_db() or schema setup function\n   - Include indices for fast lookups on summary_message_id and guild_id\n   - Add updated_at trigger or handle in application code\n\n2. **Add CRUD methods to database.py:**\n   ```python\n   def save_workflow(self, guild_id, summary_message_id, original_channel_id, \n                     original_message_id, song_matches, selections={}, \n                     message_ids=[], approver_ids=[]):\n       \"\"\"Insert new workflow into database\"\"\"\n       # Convert Python objects to JSON for JSONB columns\n       # Use parameterized query to prevent SQL injection\n       # Return workflow ID\n   \n   def get_workflow(self, summary_message_id):\n       \"\"\"Retrieve workflow by summary message ID\"\"\"\n       # Query by summary_message_id (indexed for performance)\n       # Parse JSONB columns back to Python objects\n       # Return workflow dict or None\n   \n   def get_all_active_workflows(self, guild_id=None):\n       \"\"\"Load all active workflows, optionally filtered by guild\"\"\"\n       # Used during bot startup to restore state\n       # Return list of workflow dicts\n   \n   def update_workflow_selection(self, summary_message_id, song_number, selected_track):\n       \"\"\"Update a single song selection in workflow\"\"\"\n       # Update selections JSONB field\n       # Update updated_at timestamp\n       # Use atomic transaction\n   \n   def update_workflow(self, summary_message_id, **kwargs):\n       \"\"\"Update any workflow fields\"\"\"\n       # Generic update method for selections, message_ids, approver_ids\n       # Update updated_at timestamp\n   \n   def delete_workflow(self, summary_message_id):\n       \"\"\"Remove completed or cancelled workflow\"\"\"\n       # Delete by summary_message_id\n       # Return success boolean\n   ```\n\n3. **Update bot.py on_ready() event handler:**\n   ```python\n   async def on_ready(self):\n       # Existing startup logic...\n       \n       # Load active workflows from database\n       workflows = self.db.get_all_active_workflows()\n       for workflow_data in workflows:\n           # Reconstruct workflow dict from database record\n           self.active_workflows[workflow_data['summary_message_id']] = {\n               'guild_id': workflow_data['guild_id'],\n               'original_channel_id': workflow_data['original_channel_id'],\n               'original_message_id': workflow_data['original_message_id'],\n               'song_matches': workflow_data['song_matches'],\n               'selections': workflow_data['selections'],\n               'message_ids': workflow_data['message_ids'],\n               'approver_ids': workflow_data['approver_ids']\n           }\n       \n       self.logger.info(f\"Restored {len(workflows)} active workflows from database\")\n   ```\n\n4. **Update send_approval_workflow() in bot.py:**\n   - After creating workflow in memory, immediately persist to database\n   ```python\n   # After: self.active_workflows[summary_msg.id] = workflow\n   self.db.save_workflow(\n       guild_id=workflow['guild_id'],\n       summary_message_id=summary_msg.id,\n       original_channel_id=workflow['original_channel_id'],\n       original_message_id=workflow['original_message_id'],\n       song_matches=workflow['song_matches'],\n       selections=workflow['selections'],\n       message_ids=workflow['message_ids'],\n       approver_ids=workflow['approver_ids']\n   )\n   ```\n\n5. **Update reaction handler (on_raw_reaction_add):**\n   - When updating selections in memory, also update database\n   ```python\n   # After updating workflow['selections'][song_number]\n   self.db.update_workflow_selection(\n       summary_message_id=payload.message_id,\n       song_number=song_number,\n       selected_track=selected_track\n   )\n   ```\n\n6. **Update handle_dm_message() for manual song submissions:**\n   - When user replies with Spotify URL, update database\n   ```python\n   # After: workflow['selections'][song_number] = track_data\n   self.db.update_workflow_selection(\n       summary_message_id=workflow_key,\n       song_number=song_number,\n       selected_track=track_data\n   )\n   ```\n\n7. **Update cleanup_workflow() in bot.py:**\n   - Delete from database when workflow completes or is cancelled\n   ```python\n   def cleanup_workflow(self, summary_message_id):\n       if summary_message_id in self.active_workflows:\n           del self.active_workflows[summary_message_id]\n       \n       # Delete from database\n       self.db.delete_workflow(summary_message_id)\n       self.logger.info(f\"Cleaned up workflow {summary_message_id}\")\n   ```\n\n8. **Error Handling:**\n   - Wrap all database operations in try/except blocks\n   - Log database errors but don't crash the bot\n   - If DB write fails, keep in-memory state and retry on next update\n   - Consider adding a background task to sync memory to DB periodically\n\n9. **Migration Considerations:**\n   - Add schema migration script or use Alembic\n   - Handle existing in-memory workflows during deployment (optional: persist before shutdown)\n   - Add database version tracking\n\nTECHNICAL CONSIDERATIONS:\n- Use parameterized queries to prevent SQL injection\n- Ensure atomic transactions for all workflow updates\n- Handle JSON serialization/deserialization carefully (datetime objects, etc.)\n- Consider adding workflow expiration (auto-cleanup after 24-48 hours)\n- Add logging for all database operations for debugging\n- Test with SQLite's JSONB support (or JSON for older versions)",
        "testStrategy": "1. **Schema Validation:**\n   - Run database initialization and verify active_workflows table is created\n   - Confirm all columns, data types, and constraints are correct\n   - Verify indices exist on summary_message_id and guild_id\n   - Check JSONB columns can store and retrieve complex objects\n\n2. **CRUD Operations Test:**\n   - Test save_workflow() with complete workflow data\n   - Test get_workflow() retrieves correct workflow by summary_message_id\n   - Test get_all_active_workflows() returns all workflows, filtered by guild\n   - Test update_workflow_selection() updates specific song selection\n   - Test delete_workflow() removes workflow from database\n   - Verify all operations use parameterized queries (check SQL logs)\n\n3. **Bot Startup Restoration Test:**\n   - Create 2-3 active workflows with different states (some with selections, some without)\n   - Verify workflows are persisted to database\n   - Restart the bot (simulate disconnect/crash)\n   - Confirm on_ready() loads all workflows from database into memory\n   - Verify self.active_workflows dict matches database state\n   - Check logs confirm number of restored workflows\n\n4. **End-to-End Workflow Persistence Test:**\n   - Trigger setlist detection to create new workflow\n   - Verify workflow is saved to database immediately\n   - Make song selections via reactions\n   - Query database and confirm selections are updated\n   - Reply to DM with manual Spotify URL\n   - Verify database reflects manual selection\n   - Complete workflow with ✅ reaction\n   - Confirm workflow is deleted from database after completion\n\n5. **Bot Restart During Active Workflow Test:**\n   - Start approval workflow and make partial song selections\n   - Query database to confirm workflow and selections are persisted\n   - Restart bot while workflow is active\n   - Verify workflow is restored to memory on startup\n   - Continue making selections and verify they update in database\n   - Complete workflow and verify it's cleaned up from database\n\n6. **Concurrent Workflow Test:**\n   - Create multiple workflows simultaneously (different setlists/guilds)\n   - Verify each workflow has unique summary_message_id\n   - Update selections in different workflows\n   - Confirm database maintains separate state for each workflow\n   - Complete one workflow, verify others remain in database\n\n7. **Error Handling Test:**\n   - Simulate database connection failure during workflow save\n   - Verify bot logs error but doesn't crash\n   - Simulate database failure during selection update\n   - Confirm in-memory state is maintained\n   - Test recovery when database connection is restored\n\n8. **Data Integrity Test:**\n   - Create workflow with complex song_matches (multiple tracks, metadata)\n   - Verify JSONB serialization preserves all data\n   - Retrieve workflow and confirm all fields match original\n   - Test with special characters, Unicode, and edge cases in song data\n\n9. **Cleanup and Expiration Test:**\n   - Create workflow and complete it\n   - Verify delete_workflow() removes it from database\n   - Create workflow and cancel it (if cancellation feature exists)\n   - Confirm cancelled workflows are also cleaned up\n   - Query database to ensure no orphaned workflow records\n\n10. **Performance Test:**\n    - Create 10+ workflows and measure get_workflow() query time\n    - Verify index on summary_message_id provides fast lookups (<10ms)\n    - Test get_all_active_workflows() with multiple guilds\n    - Confirm queries scale reasonably with workflow count",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "13"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-18T15:39:43.738Z"
      },
      {
        "id": "15",
        "title": "Add pytest test suite for JamBot Discord bot",
        "description": "Create comprehensive pytest test suite with tests/ directory structure, pytest.ini configuration, and test files for database operations, Discord command handlers, and bot workflow logic with mocked Discord.py and Spotify API responses.",
        "details": "DIRECTORY STRUCTURE:\nCreate the following test directory structure:\n```\ntests/\n├── __init__.py\n├── conftest.py          # Shared fixtures and pytest configuration\n├── test_database.py     # Database CRUD and migration tests\n├── test_commands.py     # Slash command handler tests\n├── test_bot.py          # Workflow logic and reaction handler tests\n└── fixtures/\n    ├── __init__.py\n    ├── discord_fixtures.py   # Mock Discord objects\n    └── spotify_fixtures.py   # Mock Spotify API responses\n```\n\nPYTEST.INI CONFIGURATION:\nCreate pytest.ini in project root:\n```ini\n[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\nasyncio_mode = auto\nmarkers =\n    unit: Unit tests\n    integration: Integration tests\n    database: Database tests\n    discord: Discord bot tests\n    spotify: Spotify API tests\naddopts = \n    -v\n    --strict-markers\n    --cov=src\n    --cov-report=html\n    --cov-report=term-missing\n    --asyncio-mode=auto\n```\n\nCONFTEST.PY - SHARED FIXTURES:\n```python\nimport pytest\nimport sqlite3\nfrom unittest.mock import AsyncMock, MagicMock, patch\nimport discord\nfrom discord.ext import commands\n\n@pytest.fixture\ndef test_db():\n    \"\"\"Create in-memory test database\"\"\"\n    conn = sqlite3.connect(':memory:')\n    # Run schema creation from database.py\n    cursor = conn.cursor()\n    # Execute schema SQL\n    yield conn\n    conn.close()\n\n@pytest.fixture\ndef mock_bot():\n    \"\"\"Mock Discord bot instance\"\"\"\n    bot = MagicMock(spec=commands.Bot)\n    bot.user = MagicMock(id=123456789)\n    return bot\n\n@pytest.fixture\ndef mock_guild():\n    \"\"\"Mock Discord guild\"\"\"\n    guild = MagicMock(spec=discord.Guild)\n    guild.id = 987654321\n    guild.name = \"Test Server\"\n    return guild\n\n@pytest.fixture\ndef mock_channel():\n    \"\"\"Mock Discord text channel\"\"\"\n    channel = AsyncMock(spec=discord.TextChannel)\n    channel.id = 111222333\n    channel.send = AsyncMock()\n    return channel\n\n@pytest.fixture\ndef mock_user():\n    \"\"\"Mock Discord user\"\"\"\n    user = MagicMock(spec=discord.User)\n    user.id = 444555666\n    user.name = \"TestUser\"\n    user.send = AsyncMock()\n    return user\n\n@pytest.fixture\ndef mock_interaction():\n    \"\"\"Mock Discord interaction for slash commands\"\"\"\n    interaction = AsyncMock(spec=discord.Interaction)\n    interaction.response = AsyncMock()\n    interaction.followup = AsyncMock()\n    interaction.user = MagicMock(id=444555666)\n    return interaction\n```\n\nTEST_DATABASE.PY - DATABASE TESTS:\n```python\nimport pytest\nfrom src.database import (\n    initialize_database,\n    add_or_update_song,\n    get_song_by_title,\n    create_setlist,\n    add_song_to_setlist,\n    get_setlist_songs,\n    run_migrations\n)\n\n@pytest.mark.database\ndef test_initialize_database(test_db):\n    \"\"\"Test database schema creation\"\"\"\n    initialize_database(test_db)\n    cursor = test_db.cursor()\n    \n    # Verify tables exist\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n    tables = {row[0] for row in cursor.fetchall()}\n    assert 'songs' in tables\n    assert 'setlists' in tables\n    assert 'setlist_songs' in tables\n    assert 'active_workflows' in tables\n\n@pytest.mark.database\ndef test_add_or_update_song(test_db):\n    \"\"\"Test adding and updating songs\"\"\"\n    initialize_database(test_db)\n    \n    # Add new song\n    song_id = add_or_update_song(\n        test_db,\n        title=\"Blue Moon of Kentucky\",\n        spotify_track_id=\"abc123\",\n        artist=\"Bill Monroe\",\n        album=\"Test Album\",\n        spotify_url=\"https://open.spotify.com/track/abc123\"\n    )\n    assert song_id is not None\n    \n    # Verify song exists\n    song = get_song_by_title(test_db, \"Blue Moon of Kentucky\")\n    assert song is not None\n    assert song['artist'] == \"Bill Monroe\"\n    \n    # Update existing song\n    updated_id = add_or_update_song(\n        test_db,\n        title=\"Blue Moon of Kentucky\",\n        spotify_track_id=\"xyz789\",\n        artist=\"Bill Monroe & His Blue Grass Boys\",\n        album=\"Updated Album\",\n        spotify_url=\"https://open.spotify.com/track/xyz789\"\n    )\n    assert updated_id == song_id\n    \n    # Verify update\n    updated_song = get_song_by_title(test_db, \"Blue Moon of Kentucky\")\n    assert updated_song['spotify_track_id'] == \"xyz789\"\n\n@pytest.mark.database\ndef test_create_setlist_and_add_songs(test_db):\n    \"\"\"Test setlist creation and song associations\"\"\"\n    initialize_database(test_db)\n    \n    # Create setlist\n    setlist_id = create_setlist(\n        test_db,\n        date=\"2024-01-15\",\n        guild_id=987654321,\n        channel_id=111222333,\n        playlist_url=\"https://open.spotify.com/playlist/test123\"\n    )\n    assert setlist_id is not None\n    \n    # Add songs to setlist\n    song1_id = add_or_update_song(test_db, \"Song 1\", \"track1\", \"Artist 1\", \"Album 1\", \"url1\")\n    song2_id = add_or_update_song(test_db, \"Song 2\", \"track2\", \"Artist 2\", \"Album 2\", \"url2\")\n    \n    add_song_to_setlist(test_db, setlist_id, song1_id, position=1)\n    add_song_to_setlist(test_db, setlist_id, song2_id, position=2)\n    \n    # Verify setlist songs\n    songs = get_setlist_songs(test_db, setlist_id)\n    assert len(songs) == 2\n    assert songs[0]['position'] == 1\n    assert songs[1]['position'] == 2\n\n@pytest.mark.database\ndef test_migrations(test_db):\n    \"\"\"Test database migration system\"\"\"\n    # Test migration execution\n    run_migrations(test_db)\n    \n    # Verify migration tracking table exists\n    cursor = test_db.cursor()\n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='schema_migrations'\")\n    assert cursor.fetchone() is not None\n```\n\nTEST_COMMANDS.PY - SLASH COMMAND TESTS:\n```python\nimport pytest\nfrom unittest.mock import AsyncMock, patch, MagicMock\nfrom src.commands import setup_slash_commands\n\n@pytest.mark.discord\n@pytest.mark.asyncio\nasync def test_setup_command_admin_only(mock_bot, mock_interaction):\n    \"\"\"Test /jambot setup command requires admin permissions\"\"\"\n    setup_slash_commands(mock_bot)\n    \n    # Mock non-admin user\n    mock_interaction.user.guild_permissions.administrator = False\n    \n    # Find setup command\n    setup_command = next(cmd for cmd in mock_bot.tree.add_command.call_args_list \n                        if 'setup' in str(cmd))\n    \n    # Invoke command\n    with pytest.raises(discord.errors.Forbidden):\n        await setup_command(mock_interaction)\n\n@pytest.mark.discord\n@pytest.mark.asyncio\nasync def test_setup_command_modal_display(mock_bot, mock_interaction):\n    \"\"\"Test /jambot setup displays configuration modal\"\"\"\n    setup_slash_commands(mock_bot)\n    \n    # Mock admin user\n    mock_interaction.user.guild_permissions.administrator = True\n    \n    # Invoke setup command\n    # Verify modal is sent\n    mock_interaction.response.send_modal.assert_called_once()\n    \n    # Verify modal has correct fields\n    modal = mock_interaction.response.send_modal.call_args[0][0]\n    assert 'jam_leaders' in str(modal)\n    assert 'approvers' in str(modal)\n```\n\nTEST_BOT.PY - WORKFLOW AND REACTION HANDLER TESTS:\n```python\nimport pytest\nfrom unittest.mock import AsyncMock, MagicMock, patch\nfrom src.bot import JamBot\n\n@pytest.fixture\ndef jam_bot(test_db, mock_bot):\n    \"\"\"Create JamBot instance with test database\"\"\"\n    with patch('src.bot.discord.Client.__init__', return_value=None):\n        bot = JamBot(database_conn=test_db)\n        bot.user = mock_bot.user\n        return bot\n\n@pytest.mark.discord\n@pytest.mark.asyncio\nasync def test_setlist_detection(jam_bot, mock_channel, mock_user):\n    \"\"\"Test setlist message detection and parsing\"\"\"\n    # Mock jam leader message\n    message = MagicMock()\n    message.author = mock_user\n    message.channel = mock_channel\n    message.content = \"\"\"\n    Tonight's setlist:\n    1. Blue Moon of Kentucky\n    2. Foggy Mountain Breakdown\n    3. Man of Constant Sorrow\n    \"\"\"\n    \n    with patch.object(jam_bot, 'is_jam_leader', return_value=True):\n        await jam_bot.on_message(message)\n    \n    # Verify workflow created\n    assert len(jam_bot.active_workflows) > 0\n\n@pytest.mark.discord\n@pytest.mark.asyncio\nasync def test_approval_reaction_handler(jam_bot, mock_user):\n    \"\"\"Test emoji reaction approval workflow\"\"\"\n    # Create mock workflow\n    workflow_id = 123456\n    jam_bot.active_workflows[workflow_id] = {\n        'guild_id': 987654321,\n        'songs': ['Song 1', 'Song 2'],\n        'selections': {0: {'spotify_track_id': 'track1'}, 1: {'spotify_track_id': 'track2'}},\n        'approver_id': mock_user.id\n    }\n    \n    # Mock reaction payload\n    payload = MagicMock()\n    payload.message_id = workflow_id\n    payload.user_id = mock_user.id\n    payload.emoji = MagicMock(name='✅')\n    \n    with patch.object(jam_bot, 'create_playlist_from_workflow', new_callable=AsyncMock) as mock_create:\n        await jam_bot.on_raw_reaction_add(payload)\n        mock_create.assert_called_once()\n\n@pytest.mark.discord\n@pytest.mark.asyncio\nasync def test_missing_songs_validation(jam_bot, mock_user):\n    \"\"\"Test workflow validation prevents playlist creation with missing songs\"\"\"\n    # Create workflow with missing song\n    workflow_id = 789012\n    jam_bot.active_workflows[workflow_id] = {\n        'guild_id': 987654321,\n        'songs': ['Song 1', 'Song 2', 'Song 3'],\n        'selections': {0: {'spotify_track_id': 'track1'}, 1: None, 2: {'spotify_track_id': 'track3'}},\n        'approver_id': mock_user.id\n    }\n    \n    payload = MagicMock()\n    payload.message_id = workflow_id\n    payload.user_id = mock_user.id\n    payload.emoji = MagicMock(name='✅')\n    \n    with patch.object(jam_bot, 'create_playlist_from_workflow', new_callable=AsyncMock) as mock_create:\n        await jam_bot.on_raw_reaction_add(payload)\n        \n        # Verify workflow not cleaned up (bug fix from Task 12)\n        assert workflow_id in jam_bot.active_workflows\n\n@pytest.mark.discord\n@pytest.mark.asyncio\nasync def test_manual_dm_song_submission(jam_bot, mock_user, test_db):\n    \"\"\"Test manual song submission via DM persists to database immediately\"\"\"\n    # Create workflow\n    workflow_id = 345678\n    jam_bot.active_workflows[workflow_id] = {\n        'guild_id': 987654321,\n        'songs': ['Unknown Song'],\n        'selections': {0: None},\n        'approver_id': mock_user.id\n    }\n    \n    # Mock DM message with Spotify URL\n    message = MagicMock()\n    message.author = mock_user\n    message.content = \"https://open.spotify.com/track/manual123\"\n    message.channel = MagicMock(type=discord.ChannelType.private)\n    \n    with patch('src.bot.extract_spotify_track_id', return_value='manual123'):\n        with patch('src.bot.get_track_details', return_value={\n            'name': 'Manual Song',\n            'artists': [{'name': 'Manual Artist'}],\n            'album': {'name': 'Manual Album'},\n            'external_urls': {'spotify': 'https://open.spotify.com/track/manual123'}\n        }):\n            await jam_bot.handle_dm_message(message)\n    \n    # Verify song persisted to database immediately (bug fix from Task 13)\n    cursor = test_db.cursor()\n    cursor.execute(\"SELECT * FROM songs WHERE spotify_track_id = ?\", ('manual123',))\n    song = cursor.fetchone()\n    assert song is not None\n\n@pytest.mark.spotify\n@pytest.mark.asyncio\nasync def test_spotify_playlist_creation(jam_bot):\n    \"\"\"Test Spotify playlist creation with mocked API\"\"\"\n    workflow = {\n        'guild_id': 987654321,\n        'channel_id': 111222333,\n        'songs': ['Song 1', 'Song 2'],\n        'selections': {\n            0: {'spotify_track_id': 'track1', 'name': 'Song 1'},\n            1: {'spotify_track_id': 'track2', 'name': 'Song 2'}\n        }\n    }\n    \n    with patch('src.bot.spotipy.Spotify') as mock_spotify:\n        mock_spotify.return_value.user_playlists_create.return_value = {\n            'id': 'playlist123',\n            'external_urls': {'spotify': 'https://open.spotify.com/playlist/playlist123'}\n        }\n        \n        playlist_url = await jam_bot.create_spotify_playlist(workflow)\n        \n        assert playlist_url == 'https://open.spotify.com/playlist/playlist123'\n        mock_spotify.return_value.playlist_add_items.assert_called_once()\n```\n\nFIXTURES/SPOTIFY_FIXTURES.PY:\n```python\nimport pytest\n\n@pytest.fixture\ndef mock_spotify_search_response():\n    \"\"\"Mock Spotify search API response\"\"\"\n    return {\n        'tracks': {\n            'items': [\n                {\n                    'id': 'track123',\n                    'name': 'Blue Moon of Kentucky',\n                    'artists': [{'name': 'Bill Monroe'}],\n                    'album': {'name': 'The Essential Bill Monroe'},\n                    'external_urls': {'spotify': 'https://open.spotify.com/track/track123'}\n                }\n            ]\n        }\n    }\n\n@pytest.fixture\ndef mock_spotify_track_details():\n    \"\"\"Mock Spotify track details response\"\"\"\n    return {\n        'id': 'track456',\n        'name': 'Foggy Mountain Breakdown',\n        'artists': [{'name': 'Flatt & Scruggs'}],\n        'album': {'name': 'Foggy Mountain Jamboree'},\n        'external_urls': {'spotify': 'https://open.spotify.com/track/track456'}\n    }\n```\n\nDEPENDENCIES:\nInstall required testing packages:\n```\npip install pytest pytest-asyncio pytest-cov pytest-mock\n```\n\nAdd to requirements-dev.txt:\n```\npytest>=7.4.0\npytest-asyncio>=0.21.0\npytest-cov>=4.1.0\npytest-mock>=3.11.0\n```",
        "testStrategy": "1. **Test Suite Execution:**\n   - Run `pytest` from project root and verify all tests are discovered\n   - Confirm pytest.ini configuration is loaded correctly\n   - Verify asyncio_mode=auto enables async test execution\n   - Check that coverage report is generated in htmlcov/ directory\n\n2. **Database Tests Validation:**\n   - Run `pytest tests/test_database.py -v` and verify all CRUD tests pass\n   - Confirm in-memory database fixture creates clean state for each test\n   - Test schema creation, song insertion, updates, and setlist operations\n   - Verify migration tests execute without errors\n   - Check that database constraints (unique, foreign keys) are enforced\n\n3. **Command Handler Tests:**\n   - Run `pytest tests/test_commands.py -v -m discord`\n   - Verify slash command registration mocks work correctly\n   - Test admin permission checks prevent unauthorized access\n   - Confirm modal display and submission handling\n   - Validate interaction response mocking\n\n4. **Bot Workflow Tests:**\n   - Run `pytest tests/test_bot.py -v -m discord`\n   - Test setlist detection and parsing from messages\n   - Verify reaction handler creates playlists on ✅ approval\n   - Confirm missing song validation prevents premature playlist creation\n   - Test manual DM song submission persists to database immediately (Task 13 fix)\n   - Verify workflow cleanup preserves active workflows when songs missing (Task 12 fix)\n\n5. **Spotify API Mocking:**\n   - Run `pytest -v -m spotify`\n   - Verify mock Spotify search returns expected track data\n   - Test playlist creation with mocked spotipy client\n   - Confirm track addition to playlist works with fixtures\n   - Validate error handling for API failures\n\n6. **Coverage Analysis:**\n   - Run `pytest --cov=src --cov-report=term-missing`\n   - Verify coverage is at least 80% for database.py, commands.py, bot.py\n   - Review coverage report to identify untested code paths\n   - Add additional tests for any critical uncovered lines\n\n7. **Integration Testing:**\n   - Run `pytest -v -m integration` for end-to-end workflow tests\n   - Test complete flow: setlist detection → song matching → approval → playlist creation\n   - Verify database persistence across workflow stages\n   - Confirm Discord and Spotify mocks integrate correctly\n\n8. **Continuous Integration:**\n   - Add pytest to CI/CD pipeline\n   - Verify tests run automatically on pull requests\n   - Confirm test failures block merges\n   - Check coverage reports are published",
        "status": "done",
        "dependencies": [
          "2",
          "4",
          "5",
          "6",
          "8",
          "11",
          "12",
          "13"
        ],
        "priority": "high",
        "subtasks": [],
        "updatedAt": "2026-01-19T03:27:59.513Z"
      },
      {
        "id": "16",
        "title": "Fix Astro Starlight Documentation Site Content Discovery Issue",
        "description": "Resolve the docsLoader content discovery bug where markdown files in subdirectories (getting-started/, setup/, guides/, reference/) are not being detected, with only index.mdx being discovered. Ensure all 9 documentation pages build and deploy correctly to jambot.app via GitHub Actions.",
        "details": "ROOT CAUSE INVESTIGATION:\nThe docsLoader is failing to discover markdown files in subdirectories, suggesting a configuration issue in content.config.ts or a Starlight version compatibility problem.\n\nIMPLEMENTATION STEPS:\n\n1. **Verify Directory Structure and File Permissions:**\n   - Confirm all subdirectories exist: getting-started/, setup/, guides/, reference/\n   - Check file permissions on all .md/.mdx files (should be readable)\n   - Verify file naming conventions match Starlight expectations\n   - List all 9 expected documentation pages and their paths\n\n2. **Audit content.config.ts Configuration:**\n   - Review the docsLoader configuration in content.config.ts\n   - Check glob patterns used for content discovery (should include subdirectories like `**/*.{md,mdx}`)\n   - Verify the base path configuration points to correct docs directory\n   - Ensure collections are properly defined for each subdirectory\n   - Example correct configuration:\n   ```typescript\n   import { defineCollection } from 'astro:content';\n   import { docsLoader } from '@astrojs/starlight/loaders';\n   \n   export const collections = {\n     docs: defineCollection({\n       loader: docsLoader({\n         base: './src/content/docs',\n         // Ensure pattern includes subdirectories\n         pattern: '**/*.{md,mdx}'\n       })\n     })\n   };\n   ```\n\n3. **Check Starlight Version Compatibility:**\n   - Review package.json for @astrojs/starlight version\n   - Check Astro version compatibility with Starlight\n   - Review Starlight changelog for breaking changes in docsLoader API\n   - Update to latest stable versions if needed\n   - Run `npm install` or `pnpm install` to ensure dependencies are properly installed\n\n4. **Verify Astro Configuration:**\n   - Check astro.config.mjs for Starlight integration setup\n   - Ensure sidebar configuration references all subdirectories\n   - Example sidebar config:\n   ```javascript\n   starlight({\n     sidebar: [\n       { label: 'Getting Started', autogenerate: { directory: 'getting-started' } },\n       { label: 'Setup', autogenerate: { directory: 'setup' } },\n       { label: 'Guides', autogenerate: { directory: 'guides' } },\n       { label: 'Reference', autogenerate: { directory: 'reference' } }\n     ]\n   })\n   ```\n\n5. **Build and Deployment Verification:**\n   - Test local build with `npm run build` or `pnpm build`\n   - Verify all 9 pages are generated in dist/ directory\n   - Check build logs for warnings or errors about missing content\n   - Review GitHub Actions workflow file (.github/workflows/*.yml)\n   - Ensure deployment step correctly uploads all built files\n   - Verify jambot.app domain configuration and DNS settings\n\n6. **Add Logging and Debugging:**\n   - Add console.log statements in content.config.ts to debug loader behavior\n   - Use Astro's --verbose flag during build to see detailed output\n   - Check if files are being excluded by .gitignore or .astroignore\n\n7. **Common Fixes:**\n   - Ensure no trailing slashes in path configurations\n   - Check for case sensitivity issues in file/directory names\n   - Verify no special characters in filenames that might break glob patterns\n   - Clear Astro cache: `rm -rf .astro` and rebuild",
        "testStrategy": "1. **Local Content Discovery Test:**\n   - Run `npm run dev` or `pnpm dev` locally\n   - Navigate to each subdirectory route in browser\n   - Verify all 9 documentation pages are accessible\n   - Check browser console and terminal for errors\n\n2. **Build Verification:**\n   - Run `npm run build` or `pnpm build`\n   - Inspect dist/ directory structure\n   - Count generated HTML files (should match 9+ pages including index)\n   - Verify subdirectory structure is preserved in output\n\n3. **Content Discovery Audit:**\n   - Add a test script to list all discovered content files\n   - Verify docsLoader finds files in all subdirectories:\n     - getting-started/\n     - setup/\n     - guides/\n     - reference/\n   - Confirm index.mdx plus all subdirectory files are included\n\n4. **GitHub Actions Deployment Test:**\n   - Push changes to repository\n   - Monitor GitHub Actions workflow execution\n   - Check build logs for successful completion\n   - Verify no warnings about missing content files\n   - Confirm deployment step completes without errors\n\n5. **Production Verification:**\n   - Visit jambot.app after deployment\n   - Navigate to each documentation section\n   - Verify all 9 pages load correctly\n   - Check navigation/sidebar shows all sections\n   - Test internal links between documentation pages\n   - Verify no 404 errors for any documentation routes\n\n6. **Regression Testing:**\n   - Add a new test markdown file in one of the subdirectories\n   - Rebuild and verify it's discovered\n   - Remove test file to confirm cleanup works",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-01-19T03:28:02.127Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-19T03:28:02.128Z",
      "taskCount": 16,
      "completedCount": 6,
      "tags": [
        "master"
      ]
    }
  }
}